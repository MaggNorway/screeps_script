<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: prototype.Creep.run.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: prototype.Creep.run.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Extensions for Creep Running.
 * @module Creep/run
 */

const [dx,dy]               =   [ [0,0,1,0,-1] , [0,1,0,-1,0] ];

/**
 * @extends Creep
 */
const creepsExtensions = {
    /**
     * Move to a position until adjacent.
     * @param   {Object} targetPos Target Position, expect to have x,y,roomName.
     * @returns {Number} OK, or error code.
     */
    adjMove(targetPos) {
        const pos = new RoomPosition(targetPos.x,targetPos.y,targetPos.roomName);
        if (this.pos.roomName !== targetPos || !this.pos.inRangeTo(pos.x,pos.y,1)) {
            this.travelTo(pos);
            return ERR_NOT_IN_RANGE;
        }
        return OK;
    },
    /**
     * Get the expected resources with specific amount.
     * @param {String} resourceType One of RESOURCE_*.
     * @param {Number|String} amount get Number, allowing for "full", indicating getting as much as possible.
     */
    getResource(resourceType,amount) {

    },
    /**
     * Harvest the target.
     * @param {Object} target The target.
     * @param {Object} targetPos Optional. The position of target, expecting x,y,roomName. If provided, will make sure adjacent.
     * @returns {Number} OK | ERR_DELETE
     */
    Harvest(target,targetPos) {
        if (targetPos &amp;&amp; this.adjMove(targetPos) === ERR_NOT_IN_RANGE) return OK;
        const feedback = this.harvest(target);
            switch (feedback) {
                case OK:
                    return OK;
                case ERR_BUSY:
                    return OK;
                case ERR_INVALID_TARGET:
                    return ERR_DELETE;
                case ERR_NOT_ENOUGH_RESOURCES:
                    return ERR_DELETE;
                default:
                    return OK;
            }
    },
    /**
     * Transfer to ... .
     * @param {Object}              toTarget        Target of Transfer.
     * @param {Object}              toTargetPos     Optional. The position of target, expecting x,y,roomName. If provided, will make sure adjacent.
     * @param {String|undefined}    resourceType    One of RESOURCE_*, or all, if undefined.
     * @param {Number|undefined}    amount          Number of transfer amount, or all, if undefined.
     * @returns {Number} OK
     */
    Transfer(toTarget,toTargetPos,resourceType,amount) {
        if (toTargetPos &amp;&amp; this.adjMove(toTargetPos) === ERR_NOT_IN_RANGE) return OK;
        const resourceTypes     = resourceType || Object.keys(this.store);
        const transferAmount    = amount       || Infinity;
        for (const _resourceType of resourceTypes) {
            if (!Number.isFinite(transferAmount)) this.transfer(toTarget,_resourceType);
            else this.transfer(toTarget,_resourceType,transferAmount);
            break;
        }
        return OK;
    },
    /**
     * Collect Resources from container, tombStone, dropped resource in the adjacent positions from pos.
     * @param {Object} pos Position, having x,y,roomName.
     * @returns {Number} OK
     */
    Collect(pos) {
        if (this.adjMove(pos) === ERR_NOT_IN_RANGE) return OK;
        // Check for potential container, tombStone, dropped resources.
        for (let i = 0; i &lt; dx.length; i++) {
            const possibleContainers = _.filter(this.room.lookForAt(LOOK_STRUCTURES,pos.x + dx[i],pos.y + dy[i]),s => s.structureType === STRUCTURE_CONTAINER &amp;&amp; s.store.getUsedCapacity() > 0);
            const possibleTombStones = _.filter(this.room.lookForAt(LOOK_TOMBSTONES,pos.x + dx[i],pos.y + dy[i]),t => t.store.getUsedCapacity() > 0);
            const possibleResources  = this.room.lookForAt(LOOK_RESOURCES,pos.x + dx[i],pos.y + dy[i]);
            for (const structure of [...possibleContainers,...possibleTombStones]) {
                for (const carry in structure.store) this.withdraw(structure,carry);
                break;
            }
            for (const resource of possibleResources) this.pickup(resource);
        }
        return OK;
    }
}

_.assign(Creep.prototype,creepsExtensions);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Creep_run.html">Creep/run</a></li><li><a href="module-Creep_task.html">Creep/task</a></li><li><a href="module-Intelligence.html">Intelligence</a></li><li><a href="module-mount.html">mount</a></li><li><a href="module-Room_utils.html">Room/utils</a></li><li><a href="module-task_main.html">task/main</a></li><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="module-Intelligence-Intelligence.html">Intelligence</a></li><li><a href="module-Intelligence-Intelligence_init.html">Intelligence_init</a></li><li><a href="module-Intelligence-Intelligence_task.html">Intelligence_task</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Fri May 15 2020 23:56:16 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
